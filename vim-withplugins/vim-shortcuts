My custom (.vimrc) shortcuts

NERDTree:
  \N    toggle NERDTree
  \n    focus NERDTree
  \e    view current buffer in NERDTree

Vim closetag:
  >     (insert mode) auto close tag
  >>    (insert mode) indent tag below

C-k     insert line above (works in insert mode)
C-j     insert line below (works in insert mode)

C-h     move to left window split
C-l     move to right window split

C-n     toggle line number display

jj      exit insert mode

C-a     exit everything without prompt (works in insert mode)
C-z     exits without prompt (:q!) (works in insert mode)
C-x     saves (:w!) (works in insert mode)
C-c     saves (:w!) and exits (:q) (works in insert mode)

dd      delete line without copying it

F2      close (delete) current buffer without affecting window layout
F3      open a new buffer in current split
F4      switch to last visited buffer
F5      previous buffer
F6      next buffer

C-t     open a new tab
F7      previous tab
F8      next tab

C-F9    decresce current window size
C-F10   decresce current window size

F10     toggle fold

C-F11   save current session
C-F12   load saved session


=============================================
VIM SHORTCUTS (DEFAULT)


C-a == Ctrl-a
M-a == Alt-a

--------------------
General

:q        close
:w        write/saves
:wa[!]    write/save all windows [force]
:wq       write/save and close
:x        save and quit, same as wq
:q!       force close if file has changed and not save changes

v        Enter visual mode for selection of LINES
C-v      Enter visual mode for selection of BLOCKS
y        Yank/copy selected region
yy       Yank/copy entire line
"<reg>y  Yank/copy marked region into register <reg> (register from a-z)
p        Paste yanked content
"<reg>p  Paste yanked content in register <reg> (from a-z)
P        Paste yanked content BEFORE

u        Undo
C-r      Redo

:!<cmd>  Execute shell command <cmd>
C-z      send vim to background (fg brings it to front again)

--------------------
Windows

C-ws     Split current window horizontally (alternative :split)
C-wv     Split current window vertically (alternative :vsplit)
C-ww     Jump to the next window
C-wARROW Jump to window left/right/top/bottom (arrow keys) to the current
C-w#<    Shrink/resize current window from the right by # (default 1) 
C-w#>    Increase/resize current window to the right by # (default 1) 
C-wr	 Rotate window
C-wH	 Fill left side with window
C-wL	 Fill right side with window
C-wJ	 Fill bottom side with window
C-wK	 Fill top side with window


--------------------
Entering insert mode

a        Append text after the cursor
A        Append text at the end of the line
i        Insert text before the cursor
I        Insert text before the first non-blank in the line
o        Begin a new line BELOW the cursor and insert text
O        Begin a new line ABOVE the cursor and insert text 
c        Cut selection and enter insert mode
cc       Delete the current line, set insert-mode
cw       Delete word, set insert-mode
C        Delete until the end of the line and enter insert mode
dd       Delete line under curser
s        Delete a number of characters and enter insert mode.
S        Delete a number of lines and enter insert mode.

--------------------
Recording

Vim has 26 registers (a-z), select the one you want to record in, see below. Exit Record mode with ESC

q[a-z]   Start recording, everything will be recorded including movement actions.
@[a-z]   Execute the recorded actions. 

--------------------
Navigation

h        cursor left
j        cursor down
l        cursor right
k        cursor up

H        Jump to TOP of screen
M        Jump to MIDDLE of screen
L        Jump to BOTTOM of screen
C-b      Move back one full screen (page up)
C-f      Move forward one full screen (page down)
C-d      Move forward 1/2 screen; half page down
C-u      Move back (up) 1/2 screen; half page up

w        jump by start of words (punctuation considered words)
e        jump to end of words (punctuation considered words)
b        jump backward by words (punctuation considered words)
0 (zero) start of line
^        first non-blank character of line
$        end of line
G        bottom of file
g        global (must be followed by something)
gg       top of file

E        jump to end of words (no punctuation)
W        jump by words (spaces separate words)
B        jump backward by words (no punctuation)
#G       goto line #
#gg      goto line #

--------------------
Search, jump

*        search for word under cursor (forward) and highlight occurrence (see incsearch, hlsearch below)
%        jump from open/close ( / #if / ( / { to corresponding ) / #endif / } 
[{       jump to start of current code block
]}       jump to end of current code block
gd       jump to var declaration (see incsearch, hlsearch below)
f<c>     Find char <c> from current cursor position -- forwards
F<c>     Find char <c> from current cursor position -- backwards
,        Repeat previous f<c> or F<c> in opposite direction
;        Repeat previous f<c> or F<c> in same direction
'.       jump back to last edited line.
g;       jump back to last edited position.
[m       jump to start of funtion body
[i       show first declartion/use of the word under cursor
[I       show all occurrences of word under cursor in current file
[/       cursor to N previous start of a C comment

--------------------
vimgrep and quickfix list

:vimgrep /<regex>/g %        		Search for <regex> with multiple occasions per line (g) in current file (%)
:vimgrep /<C-r>// %          		On the command line, <C-r>/ (that is: CTRL-R followed by /) will insert the last search pattern.  
:vimgrep /<a>/g <filelist>   		Search in the given files (<filelist>) 
:vimgrep /<a>/g *.cc         		Search in all *.cc files current directory
:vimgrep /<a>/g **/*.cc      		Search in all *.cc files in every sub-directory (recursively) 
:vimgrep /<a>/g `find . -type f`    Search in all files that are returns by the backtick command.

:vim     short for :vimgrep

:cnext   Jump to next record/match in quickfix list
:cprev   Jump to previous record/match in quickfix list

--------------------
Marks

ma       set mark a at current cursor location
'a       jump to line of mark a (first non-blank character in line)
`a       jump to position (line and column) of mark a
d'a      delete from current line to line of mark a
d`a      delete from current cursor position to position of mark a
c'a      change text from current line to line of mark a
y`a      yank text to unnamed buffer from cursor to position of mark a
:marks   list all the current marks
:marks aB list marks a, B

--------------------
Editing

x        Delete char UNDER cursor
X        Delete char BEFORE cursor
#x       Delete the next # chars. starting from char under cursor
dw       Delete next word
dW       Delete UP TO the next word
d^       Delete up unto the beginning of the line
d$       Delete until end of the line 
D        See d$, delete until end of the line  
dd       Delete whole line
dib      Delete contents in parenthesis '(' ')' block (e.g. function args)
diB      Delete inner '{' '}' block
daB      Delete a '{' '}' block
das      Delete a senctence
diw      Delete word under cursor
df<c>    Delete until next occurence of <c> (char) found (including <c>) [in single line]
dt<c>    Delete until next occurence of <c> (char) found (without <c>!!!) [in single line]

ciw      Change word under cursor 
ciB      Change inner '{' '}' block
cf<c>    See "df<c>" but change instead of delete
ct<c>    See "dt<c>" but change instead of delete

#J       Merge # number of lines together

gq       (in visual-mode) format selected text according to line-width
gqq      format current line according to line-width
#gqq     format next #-lines  

C-n      Keyword completion
Tab      Keyword completion (SuperTab plugin)
r<c>     Replace char <c>
#r<c>    Replace follow # chars with <c>, : csock, cursor on s, 3re ceeek

:s/xxx/yyy/    Replace xxx with yyy at the first occurrence
:s/xxx/yyy/g   Replace xxx with yyy first occurrence, global (whole sentence)
:s/xxx/yyy/gc  Replace xxx with yyy global with confirm
:%s/xxx/yyy/g  Replace xxx with yyy global in the whole file

u        Convert selection (visual mode) to lowercase
U        Convert selection (visual mode) to uppercase

:g/^#/d  Delete all lines that begins with #
:g/^$/d  Delete all lines that are empty

--------------------
Misc

ga       Show ASCII of char under cursor
C-k	 Search manual entry for current word

=       Indent selected

--------------------
Key sequences


> Example: 
	Replace a word in a number of occurrences with 'bar'; use word under cursor (* or /foo):
	  * cw bar ESC n .

		*     word under cursor 'foo'
		cw    change word (enter insert mode)
		bar   typed new word 'bar'
		ESC   exit insert mode
		n     next occurrence
		.     repeat previous command 

> Example:
	Insert 3 times "Help!": Help! Help! Help!
      3i Help!_ ESC

> Example:
	Search for selected text
	    <select> y / C-r0

			<select> Select text in VISUAL mode (v)
			y        Yank selection
			/        Search for
			C-r0     Press Ctrl-R and 0 to paste in

> Example:
	Comment out selection
	  C-v <select> # ESC ESC

	  	C-v   Enter VISUAL block mode
		<sel> Select lines
		#     Comment char for programming language (perl, python, bash, etc)
		ESC   Exit
		ESC   Completes adding comment char for previous selected block

--------------------
Buffers

:ls 	List the current buffers (including their numbers).
:b <number> 	Display the buffer with the given number.
:b <partial> 	Display the first buffer matching the partial name (or press Tab for name completion).
:bd 	Delete the current buffer; will fail if unsaved (nothing is deleted).
:bd! 	Delete the current buffer; will discard any changes (changes are lost). 
:bn     Next Buffer
:bp     Previous Buffer


--------------------
Tabs


--------------------
Abbreviations

auto correction of frequently misspelled words.

:abbr Lunix Linux
:abbr accross across
:abbr hte the

--------------------
Configuration

If you set the incsearch option, Vim will show the first match for the pattern, while you are still typing it. This quickly shows a typo in the pattern.
If you set the hlsearch option, Vim will highlight all matches for the pattern with a yellow background. This gives a quick overview of where the search command will take you. In program code it can show where a variable is used. You don't even have to move the cursor to see the matches.



================================
PLUGINS

-----------------------
HOWTO install a plugin

To install a plugin, we need to know what form it comes in. It can be:

    a single .vim file
    a Vimball file
    a set of files in directories that follow an expected structure (plugin/*, syntax/*, etc.) (What makes a plugin Vundle compatible and are other plugin managers interchangeable?)

A single .vim file is supposed to be placed in the .vim/plugin directory.

A Vimball file can be installed by opening it in Vim and running :source %.

A set of files in the standard directory layout can be installed either by copying them to .vim, or using a plugin package manager.

Plugins may depend on certain features. Therefore:

    It may matter if you're using Vi or Vim,
    It may matter if you're using gVim or not (gVim typically has more features enabled while compile time than Vim on the same distribution).
    It may matter which version of Vim you're on, since a feature may have been added after your version of Vim.
    It may matter which OS you're on, especially if the plugin calls in external commands.

For most plugins, though, it may not matter.


-----------
BufExplorer
http://www.vim.org/scripts/script.php?script_id=42

> Error: Not an editor command: ^M
> Solution:
    :e bufexplorer.vim
    :w ++ff=unix
